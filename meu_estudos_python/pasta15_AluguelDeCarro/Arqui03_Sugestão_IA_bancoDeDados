"""
Dicas para Melhorar Ainda Mais o Código:
Separação de Responsabilidades (Ainda Mais Clara):

A classe GerenciadorDeDados está fazendo muitas coisas (ler dados do usuário e escolher marca/modelo). 
Você poderia considerar separá-la em classes menores com responsabilidades mais específicas. Por exemplo:
Uma classe para interação com o usuário (InterfaceUsuario).
Uma classe para gerenciar os dados dos carros (CatalogoCarros).
A classe AluguelDeCarro poderia focar apenas na lógica do aluguel para um cliente específico.
Validação de Entradas Mais Robusta:

Nas funções de leitura de dados, você poderia adicionar mais validações. Por exemplo:
Verificar se o número de dias é um valor positivo.
Verificar se a quilometragem é um valor não negativo.
Tratar entradas inesperadas de forma mais específica.
Tratamento de Exceções Mais Granular:

Em vez de um except ValueError genérico, você pode tentar capturar exceções mais específicas para lidar com diferentes tipos de erros de entrada do usuário.
Mensagens de Usuário Mais Informativas:

Fornecer mensagens mais claras e úteis ao usuário, especialmente em casos de erro ou sucesso.
Utilização de Enums (Para Marcas e Modelos):

Se a lista de marcas e modelos for relativamente estática, você poderia usar Enum do módulo enum para torná-las mais gerenciáveis e evitar erros de digitação.
Formatação Consistente:

Utilize um formatador de código como black ou autopep8 para garantir que seu código siga um padrão de estilo consistente (PEP 8).
Logging:

Para aplicações mais complexas, considere usar o módulo logging para registrar eventos importantes, erros e informações de depuração.
Armazenamento de Dados dos Clientes:

Existem várias maneiras de armazenar os dados dos clientes. A escolha depende da complexidade da sua aplicação, da quantidade de dados e da necessidade de funcionalidades avançadas. Aqui estão algumas opções comuns:

1. Arquivos de Texto (Simples):

Como funciona: Você pode salvar os dados dos clientes em um arquivo de texto simples (por exemplo, .txt ou .csv). Cada linha do arquivo representaria um cliente, e os dados seriam separados por um delimitador (como vírgula, ponto e vírgula ou tabulação).

Exemplo (CSV - Comma Separated Values):

Nome,Dias,Km,Marca,Modelo,Valor Total
João,5,200,Chevrolet,Ônix,130.00
Maria,3,150,Fiat,Argo,102.50
Python: Você pode usar o módulo csv para ler e escrever arquivos CSV de forma fácil.
"""

# Python

import csv

def salvar_cliente(cliente):
    with open('clientes.csv', 'a', newline='') as arquivo:
        writer = csv.writer(arquivo)
        writer.writerow([cliente.nome, cliente.dia, cliente.km, cliente.marca, cliente.modelo, cliente.valor_total])
    print("Dados do cliente salvos com sucesso!")

def ler_clientes():
    clientes = []
    try:
        with open('clientes.csv', 'r', newline='') as arquivo:
            reader = csv.reader(arquivo)
            next(reader, None)  # Pular o cabeçalho, se existir
            for linha in reader:
                if linha:
                    nome, dia, km, marca, modelo, valor_total = linha
                    cliente = AluguelDeCarro(nome, int(dia), int(km), marca, modelo)
                    cliente.valor_total = float(valor_total)
                    clientes.append(cliente)
    except FileNotFoundError:
        print("Arquivo de clientes não encontrado.")
    return clientes

# No seu programa principal, após calcular o valor:
# salvar_cliente(aluguel)
# lista_de_clientes = ler_clientes()
# for cliente in lista_de_clientes:
#     cliente.mostrar_valor()
"""
Vantagens: Simples de implementar, não requer dependências externas.

Desvantagens: Menos eficiente para grandes quantidades de dados, difícil de realizar consultas complexas ou atualizações seletivas.

2. Arquivos JSON:

Como funciona: JSON (JavaScript Object Notation) é um formato leve para troca de dados. Você pode armazenar os dados dos clientes como uma lista de dicionários em um arquivo .json.

Exemplo:
"""
# JSON

[
    {
        "nome": "João",
        "dia": 5,
        "km": 200,
        "marca": "Chevrolet",
        "modelo": "Ônix",
        "valor_total": 130.00
    },
    {
        "nome": "Maria",
        "dia": 3,
        "km": 150,
        "marca": "Fiat",
        "modelo": "Argo",
        "valor_total": 102.50
    }
]


#Python: Use o módulo json para trabalhar com arquivos JSON.

#Python

import json

def salvar_cliente_json(cliente):
    try:
        with open('clientes.json', 'r+') as arquivo:
            dados = json.load(arquivo)
            dados.append(cliente.__dict__)  # Converte o objeto para um dicionário
            arquivo.seek(0)
            json.dump(dados, arquivo, indent=4)
    except FileNotFoundError:
        with open('clientes.json', 'w') as arquivo:
            json.dump([cliente.__dict__], arquivo, indent=4)
    print("Dados do cliente salvos em JSON com sucesso!")

def ler_clientes_json():
    clientes = []
    try:
        with open('clientes.json', 'r') as arquivo:
            dados = json.load(arquivo)
            for cliente_data in dados:
                cliente = AluguelDeCarro(cliente_data['nome'], cliente_data['dia'], cliente_data['km'], cliente_data['marca'], cliente_data['modelo'])
                cliente.valor_total = cliente_data['valor_total']
                clientes.append(cliente)
    except FileNotFoundError:
        print("Arquivo JSON de clientes não encontrado.")
    return clientes

# No seu programa principal:
# salvar_cliente_json(aluguel)
# lista_de_clientes = ler_clientes_json()
# for cliente in lista_de_clientes:
#     cliente.mostrar_valor()
"""
Vantagens: Fácil de ler e escrever, estrutura hierárquica, bom para dados semiestruturados.

Desvantagens: Menos eficiente para consultas complexas em grandes volumes de dados.

3. Banco de Dados SQLite (Para Aplicações Menores/Locais):

Como funciona: SQLite é um banco de dados relacional leve, baseado em arquivo, que não requer um servidor separado. É ideal para aplicações desktop ou embarcadas.

Python: Use o módulo sqlite3.
"""

#Python

import sqlite3

def criar_tabela():
    conexao = sqlite3.connect('clientes.db')
    cursor = conexao.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS clientes (
            nome TEXT,
            dia INTEGER,
            km INTEGER,
            marca TEXT,
            modelo TEXT,
            valor_total REAL
        )
    ''')
    conexao.commit()
    conexao.close()

def salvar_cliente_db(cliente):
    conexao = sqlite3.connect('clientes.db')
    cursor = conexao.cursor()
    cursor.execute("INSERT INTO clientes VALUES (?, ?, ?, ?, ?, ?)",
                   (cliente.nome, cliente.dia, cliente.km, cliente.marca, cliente.modelo, cliente.valor_total))
    conexao.commit()
    conexao.close()
    print("Dados do cliente salvos no banco de dados com sucesso!")

def ler_clientes_db():
    conexao = sqlite3.connect('clientes.db')
    cursor = conexao.cursor()
    cursor.execute("SELECT * FROM clientes")
    resultados = cursor.fetchall()
    conexao.close()
    clientes = []
    for linha in resultados:
        nome, dia, km, marca, modelo, valor_total = linha
        cliente = AluguelDeCarro(nome, dia, km, marca, modelo)
        cliente.valor_total = valor_total
        clientes.append(cliente)
    return clientes

# No seu programa principal:
# criar_tabela()
# salvar_cliente_db(aluguel)
# lista_de_clientes = ler_clientes_db()
# for cliente in lista_de_clientes:
#     cliente.mostrar_valor()

"""
Vantagens: Estrutura relacional, permite consultas complexas com SQL, mais eficiente para grandes quantidades de dados do que arquivos de texto.

Desvantagens: Requer conhecimento de SQL, pode ser menos escalável para aplicações web de alto tráfego.

4. Bancos de Dados Mais Robustos (Para Aplicações Maiores/Web):

Para aplicações web ou que exigem alta escalabilidade e concorrência, você pode considerar bancos de dados como PostgreSQL, MySQL, MongoDB, etc.
Python possui bibliotecas para interagir com esses bancos de dados (por exemplo, psycopg2 para PostgreSQL, mysql.connector para MySQL, pymongo para MongoDB).
A configuração e o uso desses bancos de dados são mais complexos e geralmente envolvem um servidor de banco de dados separado.
Como Escolher?

Para projetos simples e aprendizado: Arquivos de texto ou JSON são ótimos para começar.
Para aplicações desktop ou com necessidade de consultas: SQLite é uma excelente opção.
Para aplicações web ou grandes volumes de dados: Considere bancos de dados mais robustos.
Lembre-se de importar os módulos necessários (csv, json, sqlite3) no seu código. 
Você precisará decidir em qual ponto do seu programa você quer salvar os dados (por exemplo, após o cálculo do valor do aluguel) e quando você 
gostaria de lê-los (por exemplo, ao iniciar o programa para carregar dados existentes).


"""